// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants.AutoConstants;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.DemandType;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Telescope extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private WPI_TalonSRX leftTeleMotor;
private WPI_TalonSRX rightTeleMotor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	private static final double TELE_VEL = 15000;
	private static final double TELE_ACC = 6000;

	private static double m_distance;
	private static int THRESHOLD = 50;
	private static final double TICKSPERFOOT = 1400;
	// private static final double SAFETY_TICKS_TOP = 39000;
	// private static final double SAFETY_TICKS_BOTTOM = 3000;

	private static final int kTimeoutMs = 30;
	private static final int PID_INDEX = 0;
	private static final int PID_SLOT = 0;

	private static final double PIVOT_kP = 0.2;
	private static final double PIVOT_kI = 0.0005;
	private static final double PIVOT_kD = 0.0;
	private static final double PIVOT_kF = 0;
	private static final int TELE_SMOOTHING = 4;
	private static final double FEEDFORWARD = 0.07;

	private final double VOLTAGE_STATIC = 0.2;
    private final double VOLTAGE_CLIMB = AutoConstants.teleSpeed;
    
    /**
    *
    */
    public Telescope() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
leftTeleMotor = new WPI_TalonSRX(9);
 
 

rightTeleMotor = new WPI_TalonSRX(8);
 
 


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

	brakemodeOn();
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
		SmartDashboard.putNumber("Left Tele", getLeftTeleEncoder());
		SmartDashboard.putNumber("Right Tele", getRightTeleEncoder());

		SmartDashboard.putNumber("Right Output", rightTeleMotor.get());
		SmartDashboard.putNumber("Left Output", leftTeleMotor.get());
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

	public void initializeMotors(){
		leftTeleMotor.setInverted(true);
		rightTeleMotor.setInverted(false);

		rightTeleMotor.setSensorPhase(false);
		resetTeleEncoders();
	}

	public void brakemodeOn() {
		leftTeleMotor.setNeutralMode(NeutralMode.Brake);
		rightTeleMotor.setNeutralMode(NeutralMode.Brake);
	}


	public void runTele(double l, double r) {
		leftTeleMotor.set(l);
		rightTeleMotor.set(r);
	}

	public void stopTele(){
		rightTeleMotor.set(0);
		leftTeleMotor.set(0);
	}

	public boolean pastLimitSwitch() {
		return pastLimitSwitchLeftTele()
				&& pastLimitSwitchRightTele();
	}

	public boolean pastLimitSwitchLeftTele() {
		return leftTeleMotor.getSensorCollection().isRevLimitSwitchClosed()
				|| leftTeleMotor.getSensorCollection().isFwdLimitSwitchClosed();
	}

	public boolean pastLimitSwitchRightTele() {
		return rightTeleMotor.getSensorCollection().isRevLimitSwitchClosed()
				|| rightTeleMotor.getSensorCollection().isFwdLimitSwitchClosed();
	}

	public boolean pastFwdLimitSwitchRightTele() {
		return rightTeleMotor.getSensorCollection().isFwdLimitSwitchClosed();
	}
	
	public boolean pastRevLimitSwitchRightTele() {
		return rightTeleMotor.getSensorCollection().isRevLimitSwitchClosed();
	}

	public boolean pastFwdLimitSwitchLeftTele() {
		return leftTeleMotor.getSensorCollection().isFwdLimitSwitchClosed();
	}
	
	public boolean pastRevLimitSwitchLeftTele() {
		return leftTeleMotor.getSensorCollection().isRevLimitSwitchClosed();
	}


    public void initTeleMotionMagic(){
		leftTeleMotor.configFactoryDefault();
		rightTeleMotor.configFactoryDefault();

		brakemodeOn();
		initializeMotors();

		//  leftTeleMotor.configForwardSoftLimitThreshold(SAFETY_TICKS_TOP);
		//  rightTeleMotor.configForwardSoftLimitThreshold(SAFETY_TICKS_TOP);
		// leftTeleMotor.configReverseSoftLimitThreshold(SAFETY_TICKS_BOTTOM);
		// rightTeleMotor.configReverseSoftLimitThreshold(SAFETY_TICKS_BOTTOM);

		// leftTeleMotor.configForwardSoftLimitEnable(true);
		// rightTeleMotor.configForwardSoftLimitEnable(true);
		// leftTeleMotor.configReverseSoftLimitEnable(true);
		// rightTeleMotor.configReverseSoftLimitEnable(true);


		leftTeleMotor.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, PID_INDEX, kTimeoutMs);
		rightTeleMotor.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, PID_INDEX, kTimeoutMs);

		leftTeleMotor.configNeutralDeadband(0.001, kTimeoutMs);	
		rightTeleMotor.configNeutralDeadband(0.001, kTimeoutMs);	

		leftTeleMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, 10, kTimeoutMs);
		leftTeleMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_10_MotionMagic, 10, kTimeoutMs);
		rightTeleMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, 10, kTimeoutMs);
		rightTeleMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_10_MotionMagic, 10, kTimeoutMs);

		/* Set the peak and nominal outputs */
		leftTeleMotor.configNominalOutputForward(0.15, kTimeoutMs);
		leftTeleMotor.configNominalOutputReverse(-0.15, kTimeoutMs);
		leftTeleMotor.configPeakOutputForward(1, kTimeoutMs);
		leftTeleMotor.configPeakOutputReverse(-1, kTimeoutMs);

		rightTeleMotor.configNominalOutputForward(0.15, kTimeoutMs);
		rightTeleMotor.configNominalOutputReverse(-0.15, kTimeoutMs);
		rightTeleMotor.configPeakOutputForward(1, kTimeoutMs);
		rightTeleMotor.configPeakOutputReverse(-1, kTimeoutMs);

		/* Set Motion Magic gains in slot0 - see documentation */
		leftTeleMotor.selectProfileSlot(PID_SLOT, PID_INDEX);
		leftTeleMotor.config_kF(PID_SLOT, PIVOT_kF, kTimeoutMs);
		leftTeleMotor.config_kP(PID_SLOT, PIVOT_kP, kTimeoutMs);
		leftTeleMotor.config_kI(PID_SLOT, PIVOT_kI, kTimeoutMs);
		leftTeleMotor.config_kD(PID_SLOT, PIVOT_kD, kTimeoutMs);

		rightTeleMotor.selectProfileSlot(PID_SLOT, PID_INDEX);
		rightTeleMotor.config_kF(PID_SLOT, PIVOT_kF, kTimeoutMs);
		rightTeleMotor.config_kP(PID_SLOT, PIVOT_kP, kTimeoutMs);
		rightTeleMotor.config_kI(PID_SLOT, PIVOT_kI, kTimeoutMs);
		rightTeleMotor.config_kD(PID_SLOT, PIVOT_kD, kTimeoutMs);

		/* Set acceleration and vcruise velocity - see documentation */
		leftTeleMotor.configMotionCruiseVelocity(TELE_VEL, kTimeoutMs);
		leftTeleMotor.configMotionAcceleration(TELE_ACC, kTimeoutMs);

		rightTeleMotor.configMotionCruiseVelocity(TELE_VEL, kTimeoutMs);
		rightTeleMotor.configMotionAcceleration(TELE_ACC, kTimeoutMs);

		leftTeleMotor.configMotionSCurveStrength(TELE_SMOOTHING);
		rightTeleMotor.configMotionSCurveStrength(TELE_SMOOTHING);

	}

	public void runLeftMotionMagic(double dist){

		leftTeleMotor.set(ControlMode.MotionMagic, dist, DemandType.ArbitraryFeedForward, FEEDFORWARD);
	}

	public void runRightMotionMagic(double dist){

		rightTeleMotor.set(ControlMode.MotionMagic, dist, DemandType.ArbitraryFeedForward, FEEDFORWARD);
	}
	

	public double getLeftTeleEncoder(){
		return leftTeleMotor.getSelectedSensorPosition();
	}

	public double getRightTeleEncoder(){
		return rightTeleMotor.getSelectedSensorPosition();
	}


	public void resetTeleEncoders(){
		rightTeleMotor.setSelectedSensorPosition(0);
		leftTeleMotor.setSelectedSensorPosition(0);
	}

	public void resetLeftEncoder(){
		leftTeleMotor.setSelectedSensorPosition(0);
	}

	public void resetRightEncoder(){
		rightTeleMotor.setSelectedSensorPosition(0);
	}


	public boolean isTeleAtDestination(){
		return (Math.abs(getLeftTeleEncoder() - m_distance) < THRESHOLD || Math.abs(getLeftTeleEncoder() - m_distance) < THRESHOLD);
	}

	// public boolean pastLimitSwitch(){
	// 	return leftTeleMotor.getSensorCollection().isRevLimitSwitchClosed() && rightTeleMotor.getSensorCollection().isRevLimitSwitchClosed();
	// }

	// public boolean pastLimitSwitchLeftTele(){
	// 	return leftTeleMotor.getSensorCollection().isRevLimitSwitchClosed();
	// }

	// public boolean pastLimitSwitchRightTele(){
	// 	return rightTeleMotor.getSensorCollection().isRevLimitSwitchClosed();
	// }

	// public void resetPosTop() {
    // 	leftTeleMotor.setSelectedSensorPosition(TICKS_TOP, 0, kTimeoutMs);
	// 	rightTeleMotor.setSelectedSensorPosition(TICKS_TOP, 0, kTimeoutMs);
    // }

	// public void resetPosBottom() {
    // 	leftTeleMotor.setSelectedSensorPosition(TICKS_BOTTOM, 0, kTimeoutMs);
	// 	rightTeleMotor.setSelectedSensorPosition(TICKS_BOTTOM, 0, kTimeoutMs);
    // }

	// public void overrideSoftLimit(boolean change) {
	// 	leftTeleMotor.overrideSoftLimitsEnable(change);
	// 	rightTeleMotor.overrideSoftLimitsEnable(change);
	// }


	public void setControlMode(ControlMode mode){
		leftTeleMotor.set(mode, 0);
		rightTeleMotor.set(mode, 0);
	}

	public void climbUp(){
		leftTeleMotor.set(VOLTAGE_CLIMB);
		rightTeleMotor.set(VOLTAGE_CLIMB);
	}

	public void stayHanging(){
		leftTeleMotor.set(VOLTAGE_STATIC);
		rightTeleMotor.set(VOLTAGE_STATIC);
	}

}

