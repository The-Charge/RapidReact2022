// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants.AutoConstants;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

/**
 *
 */
public class Telescope extends SubsystemBase {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private WPI_TalonSRX leftTeleMotor;
	private WPI_TalonSRX rightTeleMotor;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	private static final int ENC_ARRAY_LEN = 5;
	private static final int ENC_DIFFERENCE = 5;
	private static final double TELE_DEADBAND = 0.02;

	private int[] leftEnc = {0,0,0,0,0};
	private int[] rightEnc = {0,0,0,0,0};
	private double leftSpeed = 0.;
	private double rightSpeed = 0.;
	private int encIndex = 0;

	private final double VOLTAGE_STATIC = 0.2;
    private final double VOLTAGE_CLIMB = AutoConstants.teleSpeed;
    
    /**
    *
    */
    public Telescope() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
		leftTeleMotor = new WPI_TalonSRX(9);
		rightTeleMotor = new WPI_TalonSRX(8);
    	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
		int currentLeftEnc = (int)getLeftTeleEncoder();
		int currentRightEnc = (int)getRightTeleEncoder();
		leftEnc[encIndex] = currentLeftEnc;
		rightEnc[encIndex] = currentRightEnc;
		encIndex = (encIndex+1) % ENC_ARRAY_LEN;
		SmartDashboard.putNumber("Left Tele", currentLeftEnc);
		SmartDashboard.putNumber("Right Tele", currentRightEnc);
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

	public void initializeMotors(){
		leftTeleMotor.setInverted(true);
		rightTeleMotor.setInverted(false);

		rightTeleMotor.setSensorPhase(false);
		resetTeleEncoders();
	}

	public boolean isLeftStopped(){
		boolean stopped = Math.abs(leftEnc[0]-leftEnc[1]) < ENC_DIFFERENCE;
		for (int i = 1; i < ENC_ARRAY_LEN-1; i++){
			stopped = stopped && Math.abs(leftEnc[i]-leftEnc[i+1]) < ENC_DIFFERENCE; 
		}
		return stopped;
	}

	public boolean isRightStopped(){
		boolean stopped = Math.abs(rightEnc[0]-rightEnc[1]) < ENC_DIFFERENCE;
		for (int i = 1; i < ENC_ARRAY_LEN-1; i++){
			stopped = stopped && Math.abs(rightEnc[i]-rightEnc[i+1]) < ENC_DIFFERENCE; 
		}
		return stopped;
	}

	public void brakemodeOn() {
		leftTeleMotor.setNeutralMode(NeutralMode.Brake);
		rightTeleMotor.setNeutralMode(NeutralMode.Brake);
	}

	public void runTele(double l, double r) {
		if (Math.abs(l-leftSpeed) > TELE_DEADBAND) {
			for (int i = 0; i < ENC_ARRAY_LEN; i++) leftEnc[i] = i*ENC_DIFFERENCE;
		}
		leftSpeed = l;
		if (Math.abs(r-rightSpeed) > TELE_DEADBAND) {
			for (int i = 0; i < ENC_ARRAY_LEN; i++) rightEnc[i] = i*ENC_DIFFERENCE;
		}
		rightSpeed = r;
		leftTeleMotor.set(leftSpeed);
		rightTeleMotor.set(rightSpeed);
	}

	public void stopTele(){
		runTele(leftSpeed,rightSpeed);
	}	

	public double getLeftTeleEncoder(){
		return leftTeleMotor.getSelectedSensorPosition();
	}

	public double getRightTeleEncoder(){
		return rightTeleMotor.getSelectedSensorPosition();
	}

	public void resetTeleEncoders(){
		rightTeleMotor.setSelectedSensorPosition(0);
		leftTeleMotor.setSelectedSensorPosition(0);
	}

	public void resetLeftEncoder(){
		leftTeleMotor.setSelectedSensorPosition(0);
	}

	public void resetRightEncoder(){
		rightTeleMotor.setSelectedSensorPosition(0);
	}
	
	public void setControlMode(ControlMode mode){
		leftTeleMotor.set(mode, 0);
		rightTeleMotor.set(mode, 0);
	}

	public void climbUp(){
		runTele(VOLTAGE_CLIMB, VOLTAGE_CLIMB);
	}

	public void stayHanging(){
		runTele(VOLTAGE_STATIC, VOLTAGE_STATIC);
	}
}

