// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import frc.robot.Constants;
import frc.robot.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.DemandType;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.FollowerType;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.RemoteSensorSource;
import com.ctre.phoenix.motorcontrol.SensorTerm;
import com.ctre.phoenix.motorcontrol.StatusFrame;
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Climber extends SubsystemBase {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private WPI_TalonSRX rightTeleMotor;
private WPI_TalonSRX leftTeleMotor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	private final static int kTimeoutMs = 30;

    private final static double kNeutralDeadband = 0.001;

	private static final double TICKSPERFOOT = 5270;

	private final static int REMOTE_0 = 0;
	private final static int REMOTE_1 = 1;
	private final static int PID_PRIMARY = 0;
	private final static int PID_TURN = 1;
	private final static int kSlot_Distance = 0;
	private final static int kSlot_Turning = 1;

	private static final double DISTANCE_kP = 0.1;
	private static final double DISTANCE_kI = 0.0;
	private static final double DISTANCE_kD = 0.0;
	private static final double DISTANCE_kF = 0.0;
	private static final double DISTANCE_kIzone = 100;
	private static final double DISTANCE_PEAK = 0.50;

	private static final double TURN_kP = 2.0;
	private static final double TURN_kI = 0.0;
	private static final double TURN_kD = 4.0;
	private static final double TURN_kF = 0.0;
	private static final double TURN_kIzone = 200;
	private static final double TURN_PEAK = 1.00;

	private static double m_distance;
	private static final double THRESHOLD = 100;


	/**
	*
	*/
	public Climber() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
rightTeleMotor = new WPI_TalonSRX(6);
 
 

leftTeleMotor = new WPI_TalonSRX(1);
 
 


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	}

	@Override
	public void periodic() {
		// This method will be called once per scheduler run
		SmartDashboard.putNumber("leftEnc", getLeftEncoder());
		SmartDashboard.putNumber("rightEnc", getRightEncoder());

	}

	@Override
	public void simulationPeriodic() {
		// This method will be called once per scheduler run when in simulation

	}

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initializeMotors() {
		/* Disable all motor controllers */
		rightTeleMotor.set(ControlMode.PercentOutput, 0);
		leftTeleMotor.set(ControlMode.PercentOutput, 0);

		/* Factory Default all hardware to prevent unexpected behaviour */
		rightTeleMotor.configFactoryDefault();
		leftTeleMotor.configFactoryDefault();

		/* Set Neutral Mode */
		leftTeleMotor.setNeutralMode(NeutralMode.Brake);
		rightTeleMotor.setNeutralMode(NeutralMode.Brake);

		leftTeleMotor.setInverted(true); // TRUE
		rightTeleMotor.setInverted(true); //FALSE
		// leftTeleMotor.setSensorPhase(true);
		// rightTeleMotor.setSensorPhase(false);

		/** Feedback Sensor Configuration */

		/* Configure the left Talon's selected sensor as local QuadEncoder */
		leftTeleMotor.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, // Local Feedback Source
				PID_PRIMARY, // PID Slot for Source [0, 1]
				kTimeoutMs); // Configuration Timeout

		/*
		 * Configure the Remote Talon's selected sensor as a remote sensor for the right
		 * Talon
		 */
		rightTeleMotor.configRemoteFeedbackFilter(leftTeleMotor.getDeviceID(), // Device ID of Source
				RemoteSensorSource.TalonSRX_SelectedSensor, // Remote Feedback Source
				REMOTE_0, // Source number [0, 1]
				kTimeoutMs); // Configuration Timeout

		/* Setup Sum signal to be used for Distance */
		rightTeleMotor.configSensorTerm(SensorTerm.Sum0, FeedbackDevice.RemoteSensor0, kTimeoutMs); // Feedback Device of the Remote Talon
		rightTeleMotor.configSensorTerm(SensorTerm.Sum1, FeedbackDevice.CTRE_MagEncoder_Relative, kTimeoutMs); // Quadrature Encoder of current Talon

		/* Setup Difference signal to be used for Turn */
		rightTeleMotor.configSensorTerm(SensorTerm.Diff1, FeedbackDevice.RemoteSensor0, kTimeoutMs);
		rightTeleMotor.configSensorTerm(SensorTerm.Diff0, FeedbackDevice.CTRE_MagEncoder_Relative,
				kTimeoutMs);

		/* Configure Sum [Sum of both QuadEncoders] to be used for Primary PID Index */
		rightTeleMotor.configSelectedFeedbackSensor(FeedbackDevice.SensorSum,
				PID_PRIMARY,
				kTimeoutMs);

		/* Scale Feedback by 0.5 to half the sum of Distance */
		rightTeleMotor.configSelectedFeedbackCoefficient(0.5, // Coefficient
				PID_PRIMARY, // PID Slot of Source
				kTimeoutMs); // Configuration Timeout

		/*
		 * Configure Difference [Difference between both QuadEncoders] to be used for
		 * Auxiliary PID Index
		 */
		rightTeleMotor.configSelectedFeedbackSensor(FeedbackDevice.SensorDifference,
				PID_TURN,
				kTimeoutMs);

		/* Scale the Feedback Sensor using a coefficient */
		rightTeleMotor.configSelectedFeedbackCoefficient(1,
				PID_TURN,
				kTimeoutMs);

		// /* Configure output and sensor direction */
		// leftTeleMotor.setInverted(false);
		// leftTeleMotor.setSensorPhase(true);
		// rightTeleMotor.setInverted(true);
		// rightTeleMotor.setSensorPhase(true);

		/* Set status frame periods to ensure we don't have stale data */
		rightTeleMotor.setStatusFramePeriod(StatusFrame.Status_12_Feedback1, 20, kTimeoutMs);
		rightTeleMotor.setStatusFramePeriod(StatusFrame.Status_13_Base_PIDF0, 20, kTimeoutMs);
		rightTeleMotor.setStatusFramePeriod(StatusFrame.Status_14_Turn_PIDF1, 20, kTimeoutMs);
		rightTeleMotor.setStatusFramePeriod(StatusFrame.Status_10_Targets, 20, kTimeoutMs);
		leftTeleMotor.setStatusFramePeriod(StatusFrame.Status_2_Feedback0, 5, kTimeoutMs);

		/* Configure neutral deadband */
		rightTeleMotor.configNeutralDeadband(kNeutralDeadband, kTimeoutMs);
		leftTeleMotor.configNeutralDeadband(kNeutralDeadband, kTimeoutMs);

		/* Motion Magic Configurations */
		rightTeleMotor.configMotionAcceleration(500, kTimeoutMs);
		rightTeleMotor.configMotionCruiseVelocity(2000, kTimeoutMs);

		/**
		 * Max out the peak output (for all modes).
		 * However you can limit the output of a given PID object with
		 * configClosedLoopPeakOutput().
		 */
		leftTeleMotor.configPeakOutputForward(+1.0, kTimeoutMs);
		leftTeleMotor.configPeakOutputReverse(-1.0, kTimeoutMs);
		rightTeleMotor.configPeakOutputForward(+1.0, kTimeoutMs);
		rightTeleMotor.configPeakOutputReverse(-1.0, kTimeoutMs);

		/* FPID Gains for distance servo */
		rightTeleMotor.config_kP(kSlot_Distance, DISTANCE_kP, kTimeoutMs);
		rightTeleMotor.config_kI(kSlot_Distance, DISTANCE_kI, kTimeoutMs);
		rightTeleMotor.config_kD(kSlot_Distance, DISTANCE_kD, kTimeoutMs);
		rightTeleMotor.config_kF(kSlot_Distance, DISTANCE_kF, kTimeoutMs);
		rightTeleMotor.config_IntegralZone(kSlot_Distance, DISTANCE_kIzone,
				kTimeoutMs);
		rightTeleMotor.configClosedLoopPeakOutput(kSlot_Distance, DISTANCE_PEAK,
				kTimeoutMs);
		rightTeleMotor.configAllowableClosedloopError(kSlot_Distance, 0, kTimeoutMs);

		/* FPID Gains for turn servo */
		rightTeleMotor.config_kP(kSlot_Turning, TURN_kP, kTimeoutMs);
		rightTeleMotor.config_kI(kSlot_Turning, TURN_kI, kTimeoutMs);
		rightTeleMotor.config_kD(kSlot_Turning, TURN_kD, kTimeoutMs);
		rightTeleMotor.config_kF(kSlot_Turning, TURN_kF, kTimeoutMs);
		rightTeleMotor.config_IntegralZone(kSlot_Turning, (int) TURN_kIzone,
				kTimeoutMs);
		rightTeleMotor.configClosedLoopPeakOutput(kSlot_Turning, TURN_PEAK,
				kTimeoutMs);
		rightTeleMotor.configAllowableClosedloopError(kSlot_Turning, 0, kTimeoutMs);

		/**
		 * 1ms per loop. PID loop can be slowed down if need be.
		 * For example,
		 * - if sensor updates are too slow
		 * - sensor deltas are very small per update, so derivative error never gets
		 * large enough to be useful.
		 * - sensor movement is very slow causing the derivative error to be near zero.
		 */
		int closedLoopTimeMs = 1;
		rightTeleMotor.configClosedLoopPeriod(0, closedLoopTimeMs, kTimeoutMs);
		rightTeleMotor.configClosedLoopPeriod(1, closedLoopTimeMs, kTimeoutMs);

		/**
		 * configAuxPIDPolarity(boolean invert, int timeoutMs)
		 * false means talon's local output is PID0 + PID1, and other side Talon is PID0
		 * - PID1
		 * true means talon's local output is PID0 - PID1, and other side Talon is PID0
		 * + PID1
		 */
		rightTeleMotor.configAuxPIDPolarity(false, kTimeoutMs);

		/* Initialize */
		rightTeleMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_10_Targets, 10);
		zeroSensors();
	}

	public void zeroSensors() {
		leftTeleMotor.getSensorCollection().setQuadraturePosition(0, kTimeoutMs);
		rightTeleMotor.getSensorCollection().setQuadraturePosition(0, kTimeoutMs);
	}

	public void initMotionMagic(double distance) {
		m_distance = distance;
		m_distance *= TICKSPERFOOT;

		rightTeleMotor.selectProfileSlot(kSlot_Distance, PID_PRIMARY);
		rightTeleMotor.selectProfileSlot(kSlot_Turning, PID_TURN);

		double target_turn = rightTeleMotor.getSelectedSensorPosition(1);

		rightTeleMotor.set(ControlMode.MotionMagic, m_distance, DemandType.AuxPID, target_turn);
		leftTeleMotor.follow(rightTeleMotor, FollowerType.AuxOutput1);

	}

	public double getLeftEncoder(){
		return leftTeleMotor.getSelectedSensorPosition();
	}

	public double getRightEncoder(){
		return rightTeleMotor.getSelectedSensorPosition();
	}

	public double getDistance(){
		return m_distance;
	}

	public void resetEncoders(){
		leftTeleMotor.setSelectedSensorPosition(0, 0, kTimeoutMs);
		rightTeleMotor.setSelectedSensorPosition(0, 0, kTimeoutMs);
		leftTeleMotor.setSelectedSensorPosition(0, 1, kTimeoutMs);
		rightTeleMotor.setSelectedSensorPosition(0, 1, kTimeoutMs);
	}

	public boolean isAtPIDDestination(){
		return (Math.abs(m_distance) - Math.abs(getLeftEncoder()) < THRESHOLD || Math.abs(m_distance) - Math.abs(getRightEncoder()) < THRESHOLD);
	}

	public void run(double l, double r){
		leftTeleMotor.set(l);
		rightTeleMotor.set(r);
	}

	public void stop(){
		rightTeleMotor.set(0);
		leftTeleMotor.set(0);
	}

}
